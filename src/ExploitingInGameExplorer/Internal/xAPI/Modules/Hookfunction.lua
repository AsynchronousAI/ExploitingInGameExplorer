--// Localization
local setmetatable = setmetatable
local pcall = pcall
local table = table
local debug = debug
local string = string
local coroutine = coroutine
local setfenv = setfenv
local getfenv = getfenv

--// Init
local Metatable_library = require(script.Parent.Parent.Libraries.Metatable)

--// Main
return function(old: (...any) -> (...any), new: (...any) -> (...any)?, run_on_seperate_thread: boolean?)
	local is_jammable = pcall(setfenv, old, getfenv(old))
	
	if not is_jammable then
		local name = debug.info(old, "n")
		
		if getfenv(old)[name] == old then
			getfenv(old)[name] = new
		else
			error("Unable to hook local C closures", 0)
		end
	else
		local old_environment = getfenv(old)
		
		local last_line = -1
		local last_source = function() end
		
		local debug_info = debug.info
		local hook = Metatable_library.metahook(getfenv(old), function()
			local line, source = debug_info(4, "ls")

			if line ~= last_line or last_source ~= last_source then
				if new then
					if run_on_seperate_thread then
						task.spawn(function()
							pcall(function()
								coroutine.wrap(pcall)(new)
							end)
						end)
					else
						new()
					end
				end

				last_line = line
				last_source = source
			end
		end)
		
		for i, v in pairs(old_environment) do
			rawset(hook, i, v)
		end
		
		setfenv(old, hook)
		
		return function(...)
			local return_value = {setfenv(old, old_environment)(...)}
			setfenv(old, hook)
			
			return unpack(return_value)
		end
	end
end