--// init
type userdata = {}
type _function = (...any) -> (...any)

local Metatable = {
	--[[
		A list of metamethod emulators used to call individual
		metamethods efficiently.
	]]
	metamethods = {
		__index = function(self, key)
			return self[key]
		end,
		__newindex = function(self, key, value)
			self[key] = value
		end,
		__call = function(self, ...)
			return self(...)
		end,
		__concat = function(self, b)
			return self..b
		end,
		__add = function(self, b)
			return self + b
		end,
		__sub = function(self, b)
			return self - b
		end,
		__mul = function(self, b)
			return self * b
		end,
		__div = function(self, b)
			return self / b
		end,
		__idiv = function(self, b)
			return self // b
		end,
		__mod = function(self, b)
			return self % b
		end,
		__pow = function(self, b)
			return self ^ b
		end,
		__tostring = function(self)
			return tostring(self)
		end,
		__eq = function(self, b)
			return self == b
		end,
		__lt = function(self, b)
			return self < b
		end,
		__le = function(self, b)
			return self <= b
		end,
		__len = function(self)
			return #self
		end,
		__iter = function(self)
			return next, self
		end,
		__namecall = function(self, ...)
			return self:_(...)
		end,
		__metatable = function(self)
			return getmetatable(self)
		end,
	}
}

--// methods

--[[
	Interceptive hook.

	Hooks `obj`'s metamethod `metamethod`
]]
function Metatable.get_L_closure(metamethod: string, obj: {any} | userdata)
	local hooked
	local metamethod_emulator = Metatable.metamethods[metamethod]
	
	xpcall(function()
		metamethod_emulator(obj)
	end, function()
		hooked = debug.info(2, "f")
	end)
	
	return hooked
end

--[[
	Interceptive hook.

	Attempts to scan for all available metamethods
]]
function Metatable.get_all_L_closures(obj: {any} | userdata)
	local metamethods = {}
	local innacurate = {}

	for method, _ in Metatable.metamethods do
		local metamethod, accurate = Metatable.get_L_closure(method, obj)
		metamethods[method] = metamethod
	end

	return metamethods
end

--[[
	Non-recursive hook.

	Calls `f` when a metamethod of `t` gets fired
]]
function Metatable.metahook(t: any, f: _function)
	local metahook = {
		__metatable = getmetatable(t) or "The metatable is locked"
	}

	for metamethod, value in Metatable.metamethods do
		metahook[metamethod] = function(self, ...)
			f()
			
			return Metatable.metahook({}, f) 
		end
	end

	return setmetatable({}, metahook)
end

return Metatable