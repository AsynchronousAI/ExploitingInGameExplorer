--[[

    xAPI    -   A Powerful Pentesting and Debugging Tool
    Author  -   Eskue (@SQLanguage)
    Version -   4.1

]]

--// Localization
local setmetatable = setmetatable
local pcall = pcall
local table = table
local debug = debug
local string = string
local coroutine = coroutine
local setfenv = setfenv
local getfenv = getfenv
local require = require

--// Init
local script = script

type userdata = {}
type _function = _function

local outlibrary = {}
local xAPI = {
    environment = {
		crypt = {},
		debug = {},
		cache = {},
		oth = {}
	},
	original_fenvs = {},
	environments = {},
	scopes = {},
	global_count = 0
}

function xAPI.cache(f: _function)
    return setmetatable({}, {
        __index = function(self, key)
            local value = f(key)

            self[key] = value
            return value
        end
    })
end

xAPI.service = xAPI.cache(function(service_name)
    return game:GetService(service_name)
end)

xAPI.library = xAPI.cache(function(module_name)
    return require(script.Libraries:FindFirstChild(module_name))
end)

xAPI.module = xAPI.cache(function(module_name)
	return require(script.Modules:FindFirstChild(module_name))
end)

function xAPI.addGlobal(names: {string}, value: any, libraries: {any}?)
	xAPI.global_count += 1
	
	for _, name in names do
        outlibrary[name] = value
    end
end

local type_check = xAPI.library.TypeChecking.type_check
local add_global, library, module, environment, service, scopes, environments = xAPI.addGlobal, xAPI.library, xAPI.module, xAPI.environment, xAPI.service, xAPI.scopes, xAPI.environments

local player: Player = service.Players.LocalPlayer

library.vLuau = require(script.Parent.vLuau)

--// Functions

local function _cclosure(f: _function)
	return coroutine.wrap(function(...)
		while true do
			coroutine.yield(f(...))
		end
	end)
end

local function random(length: number, a: number?, b: number?)
	local result = ""

	for _ = 1, length do
		result ..= string.char(math.random(a or 0, b or 255))
	end

	return result
end

local fake_script
do
	local safe = {
		(player and player.PlayerGui),
		(player and player.PlayerScripts),
		(player and player.Backpack)
	}
	
	fake_script = Instance.new("LocalScript", safe[math.random(1, 4)])
end

getfenv().script = fake_script

-- Instances

do
	local instances = {}
	
	for _, instance in game:GetDescendants() do
		table.insert(instances, instance)
	end
	
	game.DescendantAdded:Connect(function(instance)
		table.insert(instances, instance)
	end)
	
	add_global({"getinstances", "get_instances"}, function(): {Instance}
		return table.clone(instances)
	end)
	
	add_global({"getnilinstances", "get_nil_instances"}, function(): {Instance}
		local nil_instances = {}
		
		for _, instance in instances do
			pcall(function()
				if not instance.Parent then
					table.insert(nil_instances, instance)
				end
			end)
		end
		
		return nil_instances
	end)
	
	add_global({"getscripts", "get_scripts"}, function(): {LuaSourceContainer}
		local scripts = {}

		for _, instance in instances do
			pcall(function()
				if instance:IsA("BaseScript") then
					table.insert(scripts, instance)
				end
			end)
		end

		return scripts
	end)
	
	add_global({"getmodules", "get_modules"}, function(): {ModuleScript}
		local modules = {}

		for _, instance in instances do
			pcall(function()
				if instance:IsA("ModuleScript") then
					table.insert(modules, instance)
				end
			end)
		end

		return modules
	end)
	
	add_global({"getloadedmodules", "get_loaded_modules"}, function(): {ModuleScript}
		return environment.getmodules()
	end)
	
	add_global({"getscripthash", "get_script_hash"}, function(module: ModuleScript)
		return library.HashLib.sha256((table.find(instances, module) or -1) .. module:GetFullName())
	end)
	
	add_global({"getrunningscripts", "get_running_scripts"}, function(): {BaseScript}
		local scripts = environment.getscripts()
		local running_scripts = {}
		
		local run_check = Instance.new("Folder")
		
		local function is_destroyed(script)
			if script.Parent == nil then
				local parent_unlocked = pcall(function()
					script.Parent = run_check
					script.Parent = nil
				end)
				
				return parent_unlocked
			end
			
			return false
		end
		
		for _, script: BaseScript in scripts do
			if not is_destroyed(script) and script.Enabled and not script.Disabled then
				table.insert(running_scripts, script)
			end
		end
		
		return running_scripts
	end)
end

add_global({"isscriptable", "is_scriptable"}, function(object: Instance, property: string): boolean
	type_check(1, object, {"Instance"})
	type_check(2, property, {"string"})
	
	return select(1, pcall(function()
		return object[property]
	end))
end)

do
	local network_ownership_radius = 0
	
	add_global({"isnetworkowner", "is_network_owner"}, function(part: BasePart): boolean
		type_check(1, part, {"Instance"})

		if not part:IsA("BasePart") then
			error(("invalid argument #1 (expected BasePart, got %s)"):format(part.ClassName))
		end
		
		if part.Anchored then
			return false
		end
		
		if (part.Position - player.Character.HumanoidRootPart.Position).Magnitude <= network_ownership_radius or part:IsDescendantOf(player.Character) then
			return true
		end
		
		return false
	end)
	
	task.spawn(function()
		while task.wait(1) do
			network_ownership_radius += 0.098
		end
	end)
end

add_global({"gethui", "get_hidden_ui", "gethiddenui", "get_hui"}, function(): PlayerGui?
	return (player and player.PlayerGui)
end)

add_global({"protect_gui"}, function(gui: Instance)
	type_check(1, gui, {"Instance"})

	gui.Name = gui.ClassName
	for _, child in gui:GetDescendants() do
		child = child.ClassName
	end
end)

-- Metatable

add_global({"getrawmetatable", "get_raw_metatable"}, function(obj: any): {any}
	type_check(1, obj, {"any"})
	
	local raw_mt = library.Metatable.get_all_L_closures(obj)
	
	return setmetatable({
		__tostring = _cclosure(function(self)
			return tostring(self)
		end)
	}, {
		__index = raw_mt,
		__newindex = _cclosure(function(_, key, value)
			local success = pcall(function()
				getmetatable(obj)[key] = value
			end)
			
			if not success then error("attempt to write to a protected/read-only metatable", 2) end
		end)
	})
end)

add_global({"hookmetamethod"}, function(obj: any, method: string, hook: _function): _function
	type_check(1, obj, {"any"})
	type_check(2, method, {"string"})
	type_check(3, hook, {"function"}, true)
	
	local rmt = library.Metatable.get_all_L_closures(obj)
	local mt = getmetatable(obj)
	
	local old = rmt[method]
	local is_writable = pcall(function()
		mt[random(8)] = nil 
	end)
	
	if is_writable then
		mt[method] = hook
	else
		local is_hookable = pcall(setfenv, old, getfenv(old))
		
		if is_hookable then
			return _cclosure(module.Hookfunction(old, hook))
		else
			error("attempt to hook a non-hookable metatable", 2)
		end
	end
	
	return old
end)

add_global({"isreadonly"}, function(obj: {any}): boolean
	type_check(1, obj, {"table"})
	
	return not select(1, pcall(function()
		obj[random(math.random(8, 12))] = nil
	end))
end)

do
	local class_data = {}

	do
		local properties = module.Properties
		for _, class in properties.Classes do
			class_data[class.Name] = class.Members
		end
	end
	
	local function get_properties(obj)
		local properties = {}

		for class, members in class_data do
			if obj:IsA(class) then
				for _, property in members do
					pcall(function()
						properties[property.Name] = obj[property.Name]
					end)
				end
			end
		end

		return properties
	end
	
	add_global({"getproperties"}, function(obj: Instance): {string}
		type_check(1, obj, {"Instance"})
		
		return get_properties(obj)
	end)
end

-- Closures

add_global({"hookfunction", "replaceclosure", "hookfunc", "replacefunction", "replacefunc", "detourfunc", "detour_function"}, function(old: _function, new: _function?): _function
	type_check(1, old, {"function"})
	type_check(2, new, {"function"}, true)
	
	xAPI.original_fenvs[old] = getfenv(old)
	
	return _cclosure(module.Hookfunction(old, new))
end)

add_global({"restorefunction", "restore_function", "restore_func", "restoreclosure", "restore_closure"}, function(f: _function)
	type_check(1, f, {"function"})
	
	setfenv(f, xAPI.original_fenvs[f] or getfenv(f))
	xAPI.original_fenvs[f] = nil
end)

add_global({"isfunctionhooked", "is_function_hooked"}, function(f: _function)
	type_check(1, f, {"function"})
	
	return xAPI.original_fenvs[f] ~= nil
end)

add_global({"emulate_call", "secure_call", "securecall"}, function(f: _function, target: LuaSourceContainer, ...): ...any
	type_check(1, f, {"function"})
	type_check(2, target, {"Instance"})

	return _cclosure(function(...)
		local self_env = debug.info(1, "f")
		local real_env = getfenv(self_env)
		
		setfenv(self_env, setmetatable({
			script = fake_script,
			_G = _G,
			shared = shared
		}, {
			__index = _cclosure(function(self, index)
				return getfenv()[index]
			end),
			__newindex = _cclosure(function(self, index, value)
				rawset(self, index, value)
			end),
			__metatable = "This metatable is locked."
		}))
		
		local return_value = {f(...)}
		setfenv(self_env, real_env)
		
		return unpack(return_value)
	end)(...)
end)

add_global({"newcclosure", "new_c_closure"}, function(f: _function): _function
	type_check(1, f, {"function"})
	
	return _cclosure(f)
end)

add_global({"newlclosure", "new_l_closure"}, function(f: _function): _function
	type_check(1, f, {"function"})

	return function(...)
		return f(...)
	end
end)

add_global({"iscclosure", "is_c_closure"}, function(f: _function): boolean
	type_check(1, f, {"function"})	

	return debug.info(f, "s") == "[C]"
end)

add_global({"islclosure", "is_l_closure"}, function(f: _function): boolean
	type_check(1, f, {"function"})	
	
	return debug.info(f, "s") ~= "[C]"
end)

add_global({"dumpstring"}, function(source: string | _function | number): string
	type_check(1, source, {"string", "function", "number"})	

	local compile = library.vLuau.luau_compile
	if type(source) == "string" then
		return ({compile(source)})[1] -- select() doesn't work for some reason
	elseif type(source) == "number" then
		assert(({pcall(getfenv, source + 1)})[1], "invalid stack level")
		
		return ({compile(module.FunctionDecomp(debug.info(source + 1, "f"))[1])})[1]
	else
		if pcall(setfenv, source, getfenv(source)) then
			local decompiled = module.FunctionDecomp(source)[1]
			
			return ({compile(decompiled)})[1]
		else
			return "-- non-hookable functions are not supported"
		end
	end
end)

add_global({"loadstring"}, function(source: string, chunkname: string): _function
	type_check(1, source, {"string"})	
	type_check(2, chunkname, {"string"}, true)
	
	local f, error = library.vLuau.luau_execute(source, getfenv(2), chunkname or "@")
	
	return unpack({f, (not f and error) or nil})
end)

add_global({"checkcaller"}, function(): boolean
	for level = 1, 200 do
		local success, env = pcall(function()
			return getfenv(level)
		end)
		
		if success and table.find(environments, env) then
			return true
		end
	end
	
	return false
end)

add_global({"clonefunction", "clonefunc", "cloneclosure"}, function(f: _function): _function
	type_check(1, f, {"function"})	
	
	if debug.info(f, "s") == "[C]" then
		return _cclosure(f)
	else
		local decompilation_success, decompiled = pcall(module.FunctionDecomp, f)
		
		if decompilation_success then
			return function(...)
				return library.vLuau(decompiled[1], debug.info(f, "s"))(...)
			end
		else
			return function(...)
				return f(...)
			end
		end
	end
end)

add_global({"getidentity", "getthreadcontext", "getthreadidentity", "getcontext", "get_thread_context", "get_thread_identity"}, function(): boolean?
	local prefix = "IDENTITY:"
	local output_connection, identity
	
	output_connection = service.LogService.MessageOut:Connect(function(message: string, message_type: Enum.MessageType)
		if message:find(prefix) then
			identity = tonumber(message:sub(#prefix + 1))
			
			output_connection:Disconnect()
			output_connection = nil
		end
	end)
	
	task.wait()
	printidentity(prefix)
	
	for _ = 1, 10 do
		if not identity then
			task.wait()
			
			if not identity then printidentity(prefix) end
		else
			continue
		end
	end
	
	return identity or error("failed getting thread identity", 2)
end)

add_global({"isexecutorclosure", "checkclosure", "isourclosure"}, function(f: _function): boolean
	type_check(1, f, {"function"})
	
	local name, source = debug.info(f, "ns")
	for _, scope in scopes do
		if debug.info(scope, "s") == source then
			return true
		end
	end
	
	return source == debug.info(1, "s")
end)

add_global({"getrenv"}, function(): {any}
	local env = getfenv()
	
	return setmetatable({}, {
		__index = _cclosure(function(self, key)
			if key == "script" then return end

			return env[key]
		end),
		__metatable = "The metatable is locked"
	})
end)

add_global({"getgenv"}, function(): {any}
	return setmetatable({}, {
		__index = environment,
		__newindex = getfenv(2)
	})
end)

add_global({"decompile"}, function(f: _function | number): {any}
	type_check(1, f, {"function", "number"})
	
	if type(f) == "number" then
		f += 1
		
		if not pcall(getfenv, f + 1) then error("invalid stack level", 2) end
	end
	
	xpcall(function()
		setfenv(f, getfenv(f))
	end, function()
		error("attempt to a non-hookable function", 3)
	end)

	return module.FunctionDecomp(debug.info(f, "f"))[1]
end)

add_global({"getcallingscript", "get_calling_script"}, function(): LuaSourceContainer?
	local earliest_stack
	for i = 1, 200 do
		pcall(function()
			earliest_stack = rawget(getfenv(i), "script")
		end)
	end
	
	return earliest_stack
end)

do
	local teleport_service: TeleportService = service.TeleportService
	local queued_code = teleport_service:GetTeleportSetting("queued_code")
	local teleport_queue = {}
	
	if queued_code then
		for _, code in queued_code do
			task.spawn(library.vLuau(code))
		end
	end
	
	local teleporting = false
	if player then
		player.OnTeleport:Connect(function()
			if not teleporting then
				teleporting = true
				teleport_service:SetTeleportSetting("queued_code", teleport_queue)
			end
		end)
	end
	
	add_global({"queue_on_teleport", "queueonteleport"}, function(source: string): ()
		type_check(1, source, {"string"})
		
		table.insert(teleport_queue, source)
	end)
	
	add_global({"clear_teleport_queue", "clearteleportqueue"}, function(): ()
		table.clear(teleport_queue)
	end)
end

do
	local user_input_service: UserInputService = service.UserInputService
	
	-- clipboard
	local clipboard = ""
	
	user_input_service.InputBegan:Connect(function()
		if user_input_service:IsKeyDown(Enum.KeyCode.LeftControl) and user_input_service:IsKeyDown(Enum.KeyCode.V) then
			local focused_textbox = user_input_service:GetFocusedTextBox()
			if not focused_textbox then return end
			
			local is_accessable = pcall(function()
				return focused_textbox.Name
			end)
			
			if not is_accessable then return end
			
			local cursor_pos = focused_textbox.CursorPosition
			local pre_cursor_text = focused_textbox.Text:sub(1, cursor_pos - 1)
			local post_cursor_text = focused_textbox.Text:sub(cursor_pos, -1)
			
			focused_textbox.Text = pre_cursor_text .. clipboard .. post_cursor_text
			focused_textbox.CursorPosition = cursor_pos + #clipboard
		end
	end)
	
	add_global({"executeclipboard", "execute_clipboard", "execclipboard"}, function(...)
		return library.vLuau(clipboard)(...)
	end)
	
	add_global({"setclipboard", "set_clipboard", "toclipboard", "to_clipboard"}, function(content: string)
		type_check(1, content, {"string"})
		
		clipboard = content
	end)
	
	add_global({"getclipboard", "get_clipboard"}, function()
		return clipboard
	end)
	
	-- input
	
	-- https://github.com/VersatileTeam/hydrogen-assets/blob/main/scripts/undtc_beta.lua#L227
	local key_map = {
		[0x08] = Enum.KeyCode.Backspace,
		[0x09] = Enum.KeyCode.Tab,
		[0x0C] = Enum.KeyCode.Clear,
		[0x0D] = Enum.KeyCode.Return,
		[0x10] = Enum.KeyCode.LeftShift,
		[0x11] = Enum.KeyCode.LeftControl,
		[0x12] = Enum.KeyCode.LeftAlt,
		[0xA5] = Enum.KeyCode.RightAlt,
		[0x13] = Enum.KeyCode.Pause,
		[0x14] = Enum.KeyCode.CapsLock,
		[0x1B] = Enum.KeyCode.Escape,
		[0x20] = Enum.KeyCode.Space,
		[0x21] = Enum.KeyCode.PageUp,
		[0x22] = Enum.KeyCode.PageDown,
		[0x23] = Enum.KeyCode.End,
		[0x24] = Enum.KeyCode.Home,
		[0x25] = Enum.KeyCode.Left,
		[0x26] = Enum.KeyCode.Up,
		[0x27] = Enum.KeyCode.Right,
		[0x28] = Enum.KeyCode.Down,
		[0x2A] = Enum.KeyCode.Print,
		[0x2D] = Enum.KeyCode.Insert,
		[0x2E] = Enum.KeyCode.Delete,
		[0x2F] = Enum.KeyCode.Help,
		[0x30] = Enum.KeyCode.Zero,
		[0x31] = Enum.KeyCode.One,
		[0x32] = Enum.KeyCode.Two,
		[0x33] = Enum.KeyCode.Three,
		[0x34] = Enum.KeyCode.Four,
		[0x35] = Enum.KeyCode.Five,
		[0x36] = Enum.KeyCode.Six,
		[0x37] = Enum.KeyCode.Seven,
		[0x38] = Enum.KeyCode.Eight,
		[0x39] = Enum.KeyCode.Nine,
		[0x41] = Enum.KeyCode.A,
		[0x42] = Enum.KeyCode.B,
		[0x43] = Enum.KeyCode.C,
		[0x44] = Enum.KeyCode.D,
		[0x45] = Enum.KeyCode.E,
		[0x46] = Enum.KeyCode.F,
		[0x47] = Enum.KeyCode.G,
		[0x48] = Enum.KeyCode.H,
		[0x49] = Enum.KeyCode.I,
		[0x4A] = Enum.KeyCode.J,
		[0x4B] = Enum.KeyCode.K,
		[0x4C] = Enum.KeyCode.L,
		[0x4D] = Enum.KeyCode.M,
		[0x4E] = Enum.KeyCode.N,
		[0x4F] = Enum.KeyCode.O,
		[0x50] = Enum.KeyCode.P,
		[0x51] = Enum.KeyCode.Q,
		[0x52] = Enum.KeyCode.R,
		[0x53] = Enum.KeyCode.S,
		[0x54] = Enum.KeyCode.T,
		[0x55] = Enum.KeyCode.U,
		[0x56] = Enum.KeyCode.V,
		[0x57] = Enum.KeyCode.W,
		[0x58] = Enum.KeyCode.X,
		[0x59] = Enum.KeyCode.Y,
		[0x5A] = Enum.KeyCode.Z,
		[0x5B] = Enum.KeyCode.LeftSuper,
		[0x5C] = Enum.KeyCode.RightSuper,
		[0x60] = Enum.KeyCode.KeypadZero,
		[0x61] = Enum.KeyCode.KeypadOne,
		[0x62] = Enum.KeyCode.KeypadTwo,
		[0x63] = Enum.KeyCode.KeypadThree,
		[0x64] = Enum.KeyCode.KeypadFour,
		[0x65] = Enum.KeyCode.KeypadFive,
		[0x66] = Enum.KeyCode.KeypadSix,
		[0x67] = Enum.KeyCode.KeypadSeven,
		[0x68] = Enum.KeyCode.KeypadEight,
		[0x69] = Enum.KeyCode.KeypadNine,
		[0x6A] = Enum.KeyCode.Asterisk,
		[0x6B] = Enum.KeyCode.Plus,
		[0x6D] = Enum.KeyCode.Minus,
		[0x6E] = Enum.KeyCode.Period,
		[0x6F] = Enum.KeyCode.Slash,
		[0x70] = Enum.KeyCode.F1,
		[0x71] = Enum.KeyCode.F2,
		[0x72] = Enum.KeyCode.F3,
		[0x73] = Enum.KeyCode.F4,
		[0x74] = Enum.KeyCode.F5,
		[0x75] = Enum.KeyCode.F6,
		[0x76] = Enum.KeyCode.F7,
		[0x77] = Enum.KeyCode.F8,
		[0x78] = Enum.KeyCode.F9,
		[0x79] = Enum.KeyCode.F10,
		[0x7A] = Enum.KeyCode.F11,
		[0x7B] = Enum.KeyCode.F12,
		[0x7C] = Enum.KeyCode.F13,
		[0x7D] = Enum.KeyCode.F14,
		[0x7E] = Enum.KeyCode.F15,
		[0x90] = Enum.KeyCode.NumLock,
		[0x91] = Enum.KeyCode.ScrollLock,
		[0xA0] = Enum.KeyCode.LeftShift,
		[0xA1] = Enum.KeyCode.RightShift,
		[0xA2] = Enum.KeyCode.LeftControl,
		[0xA3] = Enum.KeyCode.RightControl,
		[0xFE] = Enum.KeyCode.Clear,
		[0xBB] = Enum.KeyCode.Equals,
		[0xDB] = Enum.KeyCode.LeftBracket,
		[0xDD] = Enum.KeyCode.RightBracket,
	}
	
	add_global({"iskeydown", "is_key_down"}, function(key_code: number)
		type_check(1, key_code, {"number"})
		
		return user_input_service:IsKeyDown(key_map[key_code])
	end)
end

-- OTH library

add_global({"hook"}, function(old: _function, new: _function?)
	type_check(1, old, {"function"})
	type_check(2, new, {"function"}, true)
	
	xAPI.original_fenvs[old] = getfenv(old)
	
	return _cclosure(_cclosure(module.Hookfunction)(old, new, true))
end, {environment.oth})

add_global({"unhook"}, function(f: _function)
	type_check(1, f, {"function"})
	
	setfenv(f, xAPI.original_fenvs[f])
	xAPI.original_fenvs[f] = nil
end, {environment.oth})

-- Misc

add_global({"identifyexecutor", "getexecutorname"}, function(): (string, string)
	return "xAPI", "v4.1"
end)

add_global({"lz4compress"}, function(data: string): string
	type_check(1, data, {"string"})
	
	return library.LZ4.compress(data)
end)

add_global({"lz4decompress"}, function(data: string): string
	type_check(1, data, {"string"})

	return library.LZ4.decompress(data)
end)

do
	local fps_cap = 0
	add_global({"setfpscap", "set_fps_cap"}, function(new_cap: number): ()
		type_check(1, new_cap, {"number"})

		fps_cap = new_cap
	end)

	add_global({"getfpscap", "get_fps_cap"}, function(): number
		return fps_cap
	end)

	task.spawn(function()
		local last_tick = os.clock()
		while true do
			if fps_cap ~= 0 then
				local current_tick = os.clock()

				if current_tick - last_tick > 1/fps_cap then
					task.wait()
					last_tick = current_tick
				end
			else
				task.wait()
			end
		end
	end)
end

add_global({"_G"}, {})
add_global({"shared"}, {})
add_global({"script"}, Instance.new("LocalScript"))

do
	local window_active = true
	local user_input_service: UserInputService = service.UserInputService
	
	user_input_service.WindowFocused:Connect(function()
		window_active = true
	end)
	
	user_input_service.WindowFocusReleased:Connect(function()
		window_active = false
	end)
	
	add_global({"isrbxactive", "isgameactive"}, function(): boolean
		return window_active
	end)
end

add_global({"isluau"}, function(): boolean
	return _VERSION == "Luau"
end)

add_global({"gethwid"}, function(): string
	local user_input_service: UserInputService = service.UserInputService
	local margin = 3
	
	local data = service.HttpService:JSONEncode({
		CPU_START = math.round((tick() - os.clock()) / margin) * margin,
		TIMEZONE = os.date("%Z"),
		IS_DST = os.date("*t").isdst,
		ACCELEROMETER_ENABLED = user_input_service.AccelerometerEnabled,
		TOUCHSCREEN_ENABLED = user_input_service.TouchEnabled
	})
	
	return library.HashLib.sha512(data)
end)

-- Cache

do
	local invalidated = {}	
	
	local function clone(instance: Instance)
		local old_archivable = instance.Archivable
		local clone

		instance.Archivable = true
		clone = instance:Clone()
		instance.Archivable = old_archivable

		return clone
	end

	add_global({"invalidate"}, function(instance: Instance): Instance
		type_check(1, instance, {"Instance"})
		
		local clone = clone(instance)
		local old_parent = instance.Parent
		
		table.insert(invalidated, instance)
		
		instance:Destroy()
		clone.Parent = old_parent 
	end, {environment.cache})

	add_global({"iscached"}, function(instance: Instance): boolean
		type_check(1, instance, {"Instance"})

		return table.find(invalidated, instance) == nil
	end, {environment.cache})
end

-- Debug

add_global({"isvalidlevel"}, function(level: number): boolean
	type_check(1, level, {"number"})
	
	return select(1, pcall(getfenv, level))
end, {environment.debug})

add_global({"getinfo"}, function(f: _function | number): {
	source: string?,
	short_src: string?,
	func: _function?,
	what: string,
	currentline: number?,
	name: string?,
	nups: number,
	numparams: number?,
	is_vararg: number
}
	
	type_check(1, f, {"number", "function"})
	
	if not pcall(getfenv, f) then
		error("Invalid stack detected", 2)
	end
	
	if f == 0 then f = 1 end
	if type(f) == "number" then f += 1 end
	
	local s, n, a, v, l, f = debug.info(f, "snalf")
	
	return {
		source = s,
		short_src = s,
		func = f,
		what = (s == "[C]" and "C") or "Lua",
		currentline = l,
		name = n,
		nups = -1,
		numparams = a,
		is_vararg = (v and 1) or 0
	}
end, {environment.debug})

add_global({"getconstants"}, function(f: _function | number): {string?}
	type_check(1, f, {"function", "number"})
	
	if type(f) == "number" then
		f += 1
		
		if not pcall(getfenv, f) then error("invalid stack level", 2) end
	end
	
	return module.FunctionDecomp(debug.info(f, "f"))[2]
end, {environment.debug})

add_global({"getconstant"}, function(f: _function | number, index: number): string?
	type_check(1, f, {"function", "number"})
	type_check(2, index, {"number"}, true)
	
	if type(f) == "number" then
		f += 1

		if not pcall(getfenv, f) then error("invalid stack level", 2) end
	end
	
	return module.FunctionDecomp(debug.info(f, "f"))[2][index]
end, {environment.debug})

add_global({"getprotos"}, function(f: _function | number)
	type_check(1, f, {"function", "number"})
	
	if type(f) == "number" then
		f += 1
		
		if not pcall(getfenv, f) then error("invalid stack level", 2) end
	end
	
	return module.FunctionDecomp(debug.info(f, "f"))[3]
end, {environment.debug})

add_global({"getproto"}, function(f: _function | number, index: number)
	type_check(1, f, {"function", "number"})
	
	if type(f) == "number" then
		f += 1

		if not pcall(getfenv, f) then error("invalid stack level", 2) end
	end
	
	return module.FunctionDecomp(debug.info(f, "f"))[3][index]
end, {environment.debug})

for i, v in debug do
	environment.debug[i] = v
end

-- Crypt

add_global({"random"}, function(length: number?): string
	type_check(1, length, {"number"}, true)
	
	return random(length or 8)
end, {environment.crypt})

add_global({"generatebytes"}, function(length: number?): string
	type_check(1, length, {"number"}, true)

	return library.HashLib.base64_encode(random(length or 8))
end, {environment.crypt})

add_global({"base64encode", "base64_encode"}, function(data: string): string
	type_check(1, data, {"string"})
	
	return library.HashLib.base64_encode(data)
end, {environment.crypt})

add_global({"base64decode", "base64_decode"}, function(data: string): string
	type_check(1, data, {"string"})
	
	return library.HashLib.base64_decode(data)
end, {environment.crypt})

add_global({"hash"}, function(data: string, algorithm: string?): string
	type_check(1, data, {"string"})
	type_check(1, algorithm, {"string"}, true)
	
	return library.HashLib[(algorithm or "sha384"):gsub("-", "_")](data)
end, {environment.crypt})

return outlibrary